import type { Env, WaitlistJoinRequest, WaitlistEntry, RateLimit } from '../../types.d.ts';

// Disposable email domains to block
const DISPOSABLE_DOMAINS = [
  'tempmail.com',
  'guerrillamail.com',
  'mailinator.com',
  '10minutemail.com',
  'throwaway.email',
  'temp-mail.org',
  'fakeinbox.com',
  'trashmail.com',
];

// Rate limit: 5 attempts per IP per hour
const RATE_LIMIT_MAX = 5;
const RATE_LIMIT_WINDOW_MS = 60 * 60 * 1000; // 1 hour

export async function onRequestPost(context: {
  request: Request;
  env: Env;
}): Promise<Response> {
  const { request, env } = context;

  try {
    // Parse request body
    const body = await request.json() as WaitlistJoinRequest;
    const { email, name, referral_code, referral_source } = body;

    // Get client IP
    const clientIP = request.headers.get('CF-Connecting-IP') || 'unknown';
    const userAgent = request.headers.get('User-Agent') || '';

    // Rate limiting check
    const rateLimitResult = await checkRateLimit(env.DB, clientIP);
    if (!rateLimitResult.allowed) {
      return jsonResponse(
        { error: 'Too many requests. Please try again later.' },
        429
      );
    }

    // Validate email
    const emailValidation = validateEmail(email);
    if (!emailValidation.valid) {
      return jsonResponse({ error: emailValidation.error }, 400);
    }

    // Check for duplicate
    const existing = await env.DB.prepare(
      'SELECT id, email_status FROM waitlist WHERE email = ?'
    )
      .bind(email.toLowerCase())
      .first<Pick<WaitlistEntry, 'id' | 'email_status'>>();

    if (existing) {
      if (existing.email_status === 'unsubscribed') {
        return jsonResponse(
          { error: 'This email has been unsubscribed. Please use a different email.' },
          409
        );
      }
      return jsonResponse(
        { error: 'This email is already on the waitlist.' },
        409
      );
    }

    // Validate referral code if provided
    let validReferralCode: string | null = null;
    if (referral_code) {
      const referrer = await env.DB.prepare(
        'SELECT id FROM waitlist WHERE invite_code = ?'
      )
        .bind(referral_code.toUpperCase())
        .first();

      if (referrer) {
        validReferralCode = referral_code.toUpperCase();
      }
      // Silently ignore invalid referral codes - don't block signup
    }

    // Generate tokens
    const verificationToken = generateToken(64);
    const unsubscribeToken = generateToken(64);

    // Insert into database
    await env.DB.prepare(
      `INSERT INTO waitlist (
        email, name, referral_code, referral_source,
        verification_token, verification_sent_at, unsubscribe_token,
        consent_given_at, consent_ip_address, consent_user_agent,
        ip_address, user_agent
      ) VALUES (?, ?, ?, ?, ?, datetime('now'), ?, datetime('now'), ?, ?, ?, ?)`
    )
      .bind(
        email.toLowerCase(),
        name || null,
        validReferralCode,
        referral_source || null,
        verificationToken,
        unsubscribeToken,
        clientIP,
        userAgent,
        clientIP,
        userAgent
      )
      .run();

    // Get the inserted record to get the invite_code (generated by trigger)
    const inserted = await env.DB.prepare(
      'SELECT invite_code FROM waitlist WHERE email = ?'
    )
      .bind(email.toLowerCase())
      .first<Pick<WaitlistEntry, 'invite_code'>>();

    // Send verification email
    await sendVerificationEmail(env, email, name, verificationToken, unsubscribeToken);

    return jsonResponse({
      success: true,
      message: 'Please check your email to verify your spot on the waitlist.',
      invite_code: inserted?.invite_code,
    });
  } catch (error) {
    console.error('Waitlist join error:', error);
    return jsonResponse(
      { error: 'Something went wrong. Please try again.' },
      500
    );
  }
}

function validateEmail(email: string): { valid: boolean; error?: string } {
  if (!email) {
    return { valid: false, error: 'Email is required.' };
  }

  // Basic email format validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return { valid: false, error: 'Please enter a valid email address.' };
  }

  // Check for disposable email domains
  const domain = email.split('@')[1].toLowerCase();
  if (DISPOSABLE_DOMAINS.some((d) => domain.includes(d))) {
    return { valid: false, error: 'Please use a non-disposable email address.' };
  }

  return { valid: true };
}

async function checkRateLimit(
  db: D1Database,
  ip: string
): Promise<{ allowed: boolean }> {
  const now = new Date();

  // Get existing rate limit record
  const existing = await db
    .prepare('SELECT * FROM rate_limits WHERE ip_address = ?')
    .bind(ip)
    .first<RateLimit>();

  if (!existing) {
    // First attempt - create record
    await db
      .prepare(
        'INSERT INTO rate_limits (ip_address, attempt_count, first_attempt_at, last_attempt_at) VALUES (?, 1, datetime(?), datetime(?))'
      )
      .bind(ip, now.toISOString(), now.toISOString())
      .run();
    return { allowed: true };
  }

  const firstAttempt = new Date(existing.first_attempt_at);
  const timeSinceFirst = now.getTime() - firstAttempt.getTime();

  if (timeSinceFirst > RATE_LIMIT_WINDOW_MS) {
    // Window expired - reset counter
    await db
      .prepare(
        'UPDATE rate_limits SET attempt_count = 1, first_attempt_at = datetime(?), last_attempt_at = datetime(?) WHERE ip_address = ?'
      )
      .bind(now.toISOString(), now.toISOString(), ip)
      .run();
    return { allowed: true };
  }

  if (existing.attempt_count >= RATE_LIMIT_MAX) {
    // Rate limit exceeded
    return { allowed: false };
  }

  // Increment counter
  await db
    .prepare(
      'UPDATE rate_limits SET attempt_count = attempt_count + 1, last_attempt_at = datetime(?) WHERE ip_address = ?'
    )
    .bind(now.toISOString(), ip)
    .run();

  return { allowed: true };
}

function generateToken(length: number): string {
  const array = new Uint8Array(length / 2);
  crypto.getRandomValues(array);
  return Array.from(array, (byte) => byte.toString(16).padStart(2, '0')).join('');
}

async function sendVerificationEmail(
  env: Env,
  email: string,
  name: string | undefined,
  verificationToken: string,
  unsubscribeToken: string
): Promise<void> {
  const verificationUrl = `${env.VERIFICATION_BASE_URL}/verify?token=${verificationToken}`;
  const unsubscribeUrl = `${env.VERIFICATION_BASE_URL}/unsubscribe?token=${unsubscribeToken}`;

  const greeting = name ? `Hi ${name}` : 'Hi there';

  const response = await fetch('https://api.resend.com/emails', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${env.RESEND_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      from: `Illoominate <${env.FROM_EMAIL}>`,
      to: [email],
      subject: 'Verify your spot on the Illoominate waitlist',
      html: `
        <div style="font-family: sans-serif; max-width: 600px; margin: 0 auto;">
          <h1 style="color: #4F46E5;">${greeting}!</h1>
          <p>Thanks for joining the Illoominate waitlist. We're building the feedback management tool we always wished we had.</p>
          <p>Click the button below to verify your email and lock in your spot:</p>
          <p style="text-align: center; margin: 32px 0;">
            <a href="${verificationUrl}" style="background-color: #4F46E5; color: white; padding: 12px 32px; text-decoration: none; border-radius: 8px; font-weight: bold; display: inline-block;">Verify My Email</a>
          </p>
          <p style="color: #666; font-size: 14px;">This link expires in 24 hours. If you didn't sign up for Illoominate, you can safely ignore this email.</p>
          <hr style="border: none; border-top: 1px solid #eee; margin: 32px 0;">
          <p style="color: #999; font-size: 12px;">
            <a href="${unsubscribeUrl}" style="color: #999;">Unsubscribe</a> | Illoominate
          </p>
        </div>
      `,
    }),
  });

  if (!response.ok) {
    const error = await response.text();
    console.error('Resend error:', error);
    throw new Error('Failed to send verification email');
  }
}

function jsonResponse(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      'Content-Type': 'application/json',
    },
  });
}
